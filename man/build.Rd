% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/build.R
\name{build}
\alias{build}
\title{Instance generation working horse.}
\usage{
build(n, iters = 10L, collection, return.all = FALSE)
}
\arguments{
\item{n}{[\code{integer(1)}]\cr
Desired instance size, i.e., the number of nodes.}

\item{iters}{[\code{integer(1)}]\cr
Number of iterations to perform.
Default is 10.}

\item{collection}{[\code{tspgen_collection}]\cr
Collection of mutation operators.}

\item{return.all}{[\code{logical(1)}]\cr
Shall all interim instances be stored and returned?
Default is \code{FALSE}.}
}
\value{
Either a netgen \code{Network} if \code{return.all = FALSE}, otherwise a
list of netgen networks of length \code{iters + 1}.
}
\description{
This function expects as parameters the desired instance size \eqn{n},
a number of iteration to perform and a collection of mutation operators. The
generation process is sequential:
\itemize{
 \item{Place \eqn{n} points uniformly at random in \eqn{[0,1]^2}. We shall denote this
set as \eqn{P} in the following.}.
 \item{For the desired number of iterations \code{iters} repeat the following
process: select a mutation operator \eqn{m} from the collection at random (according
to the probability distribution stored in \code{collection} and set \eqn{P = m(P)}.}
}
}
\note{
If \code{\link{setProbabilities}} was not called on the \code{collection}
the algorithm falls back to the uniform distribution, i.e., each mutation operator
is selected with equal probability for application in each iteration.
}
\examples{
collection = init()
collection = addMutator(collection, "doUniformMutation", pm = 0.3)
collection = addMutator(collection, "doExplosionMutation", min.eps = 0.2, max.eps = 0.4)
collection = addMutator(collection, "doImplosionMutation", min.eps = 0.2, max.eps = 0.4)
collection = addMutator(collection, "doAxisProjectionMutation")
collection = setProbabilities(collection, probs = c(0.1, 0.6, 0.2, 0.1))

x = build(n = 50, iters = 10, collection = collection)
}
